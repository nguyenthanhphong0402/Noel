<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NOEL_APP_FINAL</title>

  <style>
    body { margin: 0; overflow: hidden; background:#000; font-family: 'Times New Roman', serif; }
    #canvas-container { width: 100vw; height: 100vh; position: absolute; inset: 0; z-index: 1; }

    #ui-layer{
      position:absolute; inset:0; z-index:10; pointer-events:none;
      display:flex; flex-direction:column; align-items:center;
      padding-top:34px; box-sizing:border-box;
      transition: opacity .25s ease;
    }

    #loader{
      position:absolute; inset:0; background:#000; z-index:100;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      transition:opacity .8s ease-out;
    }
    .loader-text{
      color:#d4af37; font-size:14px; letter-spacing:4px; margin-top:20px;
      text-transform:uppercase; font-weight:100;
    }
    .spinner{
      width:40px; height:40px; border:1px solid rgba(212,175,55,.2);
      border-top:1px solid #d4af37; border-radius:50%;
      animation:spin 1s linear infinite;
    }
    @keyframes spin { 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} }

    h1{
      margin:0;
      font-size:54px; font-weight:400; letter-spacing:6px;
      text-shadow:0 0 50px rgba(252,238,167,.6);
      background:linear-gradient(to bottom,#fff,#eebb66);
      -webkit-background-clip:text; -webkit-text-fill-color:transparent;
      font-family:'Cinzel','Times New Roman',serif;
      opacity:.92;
      pointer-events:none;
      text-align:center;
      padding: 0 14px;
    }

    #subtitle{
      margin-top:10px;
      color:rgba(255,255,255,.72);
      font-size:12px;
      letter-spacing:1px;
      text-transform:uppercase;
      pointer-events:none;
      text-align:center;
      padding: 0 14px;
      transition: opacity .25s ease;
    }

    .controls{
      margin-top:18px;
      pointer-events:auto;
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center; justify-content:center;
      transition:opacity .25s ease;
      padding: 0 14px;
    }
    .btn{
      background:rgba(20,20,20,.6);
      border:1px solid rgba(212,175,55,.35);
      color:#d4af37;
      padding:10px 14px;
      cursor:pointer;
      text-transform:uppercase;
      letter-spacing:2px;
      font-size:10px;
      transition:all .25s;
      display:inline-flex;
      align-items:center;
      gap:8px;
      backdrop-filter:blur(6px);
      border-radius:999px;
      user-select:none;
    }
    .btn:hover{
      background:#d4af37;
      color:#000;
      box-shadow:0 0 18px rgba(212,175,55,.4);
    }
    .btn.secondary{
      border-color: rgba(255,255,255,.12);
      color: rgba(255,255,255,.85);
    }
    .btn.secondary:hover{
      background: rgba(255,255,255,.9);
      color:#000;
      box-shadow:0 0 18px rgba(255,255,255,.25);
    }
    .btn input{ display:none; }

    #hint{
      margin-top:10px;
      color:rgba(212,175,55,.55);
      font-size:9px;
      letter-spacing:1px;
      text-transform:uppercase;
      pointer-events:none;
      text-align:center;
      padding: 0 14px;
      transition: opacity .25s ease;
    }

    #status-pill{
      margin-top:12px;
      color:rgba(255,255,255,.65);
      font-size:11px;
      letter-spacing:1px;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.08);
      padding:7px 11px;
      border-radius:999px;
      pointer-events:none;
      backdrop-filter:blur(6px);
      text-align:center;
      max-width: min(560px, 92vw);
      line-height: 1.35;
      transition: opacity .25s ease;
    }

    .ui-hidden { display:none !important; }

    /* Mobile App UI bar */
    #appbar { display:none; }
    @media (max-width: 768px) {
      #controls { display:none !important; }
      #hint { display:none !important; }
      #subtitle { font-size: 11px; opacity: .85; }

      #appbar{
        display:flex;
        position:fixed;
        left:12px; right:12px; bottom:14px;
        z-index:50;
        gap:10px;
        padding:10px 12px;
        border-radius:18px;
        background:rgba(0,0,0,.45);
        border:1px solid rgba(255,255,255,.10);
        backdrop-filter: blur(10px);
        align-items:center;
        justify-content:space-between;
        pointer-events:auto;
        transition: opacity .25s ease;
      }
      .appbtn{
        flex: 1;
        border:1px solid rgba(255,255,255,.12);
        background: rgba(255,255,255,.06);
        color: rgba(255,255,255,.92);
        padding: 10px 10px;
        border-radius: 14px;
        font-size: 12px;
        letter-spacing: .5px;
        text-transform: uppercase;
        cursor: pointer;
        user-select: none;
      }
      .appbtn:active{ transform: scale(.98); }
      .appbtn.primary{
        border-color: rgba(212,175,55,.35);
        background: rgba(212,175,55,.18);
        color: #f7e6a6;
      }
    }

    .ui-off #ui-layer{ opacity:0; pointer-events:none; }
    .ui-off #appbar{ opacity:0; pointer-events:none; }
  </style>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
      }
    }
  </script>
</head>

<body>
  <div id="loader">
    <div class="spinner"></div>
    <div class="loader-text">Loading Holiday Magic</div>
  </div>

  <div id="canvas-container"></div>

  <div id="ui-layer">
    <h1 id="title">NOEL</h1>
    <div id="subtitle">Mobile: 1 ng√≥n xoay ‚Ä¢ 2 ng√≥n zoom ‚Ä¢ double tap focus ‚Ä¢ swipe ƒë·ªïi mode</div>

    <!-- Desktop controls -->
    <div class="controls" id="controls">
      <label class="btn">
        üñºÔ∏è Th√™m ·∫£nh
        <input type="file" id="file-input" multiple accept="image/*">
      </label>

      <button class="btn" id="btn-music">üé∂ Nh·∫°c: T·∫Øt</button>

      <label class="btn secondary">
        ‚¨ÜÔ∏è Upload nh·∫°c
        <input type="file" id="audio-input" accept="audio/*">
      </label>

      <button class="btn secondary" id="btn-snow">‚ùÑÔ∏è Tuy·∫øt: B·∫≠t</button>
      <button class="btn secondary" id="btn-mode">üîÅ Mode: TREE</button>
      <button class="btn secondary" id="btn-ui">üôà ·∫®n UI</button>
    </div>

    <div id="hint">PC: 1=Tree ‚Ä¢ 2=Scatter ‚Ä¢ 3=Focus ‚Ä¢ ESC=Tho√°t ‚Ä¢ Space=Nh·∫°c ‚Ä¢ S=Tuy·∫øt ‚Ä¢ H=·∫®n UI</div>
    <div id="status-pill">Gesture camera: ch·ªâ h·ªó tr·ª£ t·ªët tr√™n PC. iPhone s·∫Ω t·ª± t·∫Øt v√† d√πng touch.</div>
  </div>

  <!-- Mobile App Bar -->
  <div id="appbar">
    <button class="appbtn" id="m-toggle-ui">üôà UI</button>
    <button class="appbtn" id="m-add-photo">üñºÔ∏è ·∫¢NH</button>
    <button class="appbtn" id="m-upload-audio">‚¨ÜÔ∏è NH·∫†C</button>
    <button class="appbtn primary" id="m-mode">üå≤ TREE</button>
    <button class="appbtn" id="m-snow">‚ùÑÔ∏è TUY·∫æT</button>
    <button class="appbtn" id="m-play">üéµ PH√ÅT</button>
    <button onclick="toggleMusic()">üéµ NH·∫†C</button>
  </div>

  <!-- hidden webcam (PC only) -->
  <div id="webcam-wrapper" style="display:none;">
    <video id="webcam" autoplay playsinline style="display:none;"></video>
  </div>

  <audio id="bgm" crossorigin="anonymous"></audio>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    const $ = (sel) => document.querySelector(sel);

    const titleEl = $("#title");
    const subtitleEl = $("#subtitle");
    const statusEl = $("#status-pill");

    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    const isMobile = matchMedia("(max-width: 768px)").matches || /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    const DPR = Math.min(window.devicePixelRatio || 1, isMobile ? 1.6 : 2.0);

    function setStatus(t){ statusEl.textContent = t; }
    function setTitle(t){ titleEl.textContent = t; }

    const GREETINGS = [
      "Merry Christmas ‚ú®",
      "Gi√°ng Sinh An L√†nh üéÑ",
      "An Nhi√™n & ·∫§m √Åp ü§ç",
      "Ch√∫c B·∫°n Vui V·∫ª üéÅ",
      "H·∫°nh Ph√∫c Ng·∫≠p Tr√†n ‚ú®",
      "Peace ‚Ä¢ Love ‚Ä¢ Joy üïØÔ∏è",
      "Noel Vui V·∫ª ü•Ç",
      "Th·∫≠t Nhi·ªÅu May M·∫Øn ‚≠ê"
    ];
    function randomGreeting(){
      return GREETINGS[Math.floor(Math.random()*GREETINGS.length)];
    }

    // UI toggle
    function toggleUI(){
      document.body.classList.toggle("ui-off");
      const hidden = document.body.classList.contains("ui-off");
      const m = document.getElementById("m-toggle-ui");
      if(m) m.textContent = hidden ? "üëÄ UI" : "üôà UI";
      const d = document.getElementById("btn-ui");
      if(d) d.textContent = hidden ? "üëÄ Hi·ªán UI" : "üôà ·∫®n UI";
    }

    // ---------- CONFIG ----------
    const CONFIG = {
      colors: {
        bg: 0x000000,
        champagneGold: 0xffd966,
        deepGreen: 0x03180a,
        accentRed: 0x990000,
      },
      particles: {
        count: isMobile ? 900 : 1500,
        dustCount: isMobile ? 1400 : 2500,
        treeHeight: 24,
        treeRadius: 8
      },
      snow: {
        count: isMobile ? 900 : 1800,
        area: 60,
        fallSpeed: 8.5,
        drift: 1.2
      },
      camera: { z: 50 }
    };

    const STATE = {
      mode: 'TREE',
      modeTarget: 'TREE',
      focusTarget: null,

      rotation: { x: 0, y: 0 },
      rotationTarget: { x: 0, y: 0 },

      snowOn: true,
      musicOn: false,
      audioReady: false,
      beat: 0
    };

    let scene, camera, renderer, composer, bloomPass;
    let mainGroup;
    let clock = new THREE.Clock();

    let particleSystem = [];
    let photoMeshGroup = new THREE.Group();

    let ambient, innerLight, spotGold, spotBlue, fill;

    // Raycaster click photo
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    // Snow
    let snowPoints = null, snowGeo = null, snowVel = null;

    // Audio
    const audioEl = $("#bgm");
    let audioCtx = null, analyser = null, sourceNode = null, freqData = null;

    // textures
    let caneTexture = null;

    async function init(){
      initThree();
      setupEnvironment();
      setupLights();
      createTextures();
      createParticles();
      createDust();
      createSnow();
      setupPostProcessing();
      setupEvents();

      const loader = $("#loader");
      loader.style.opacity = 0;
      setTimeout(() => loader.remove(), 800);

      if (isIOS) statusEl.classList.add('ui-hidden');

      animate();
    }

    function initThree(){
      const container = $("#canvas-container");

      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.colors.bg);
      scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.01);

      camera = new THREE.PerspectiveCamera(42, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, CONFIG.camera.z);

      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:"high-performance" });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(DPR);
      renderer.toneMapping = THREE.ReinhardToneMapping;
      renderer.toneMappingExposure = 2.2;

      container.appendChild(renderer.domElement);

      mainGroup = new THREE.Group();
      scene.add(mainGroup);
      mainGroup.add(photoMeshGroup);
    }

    function setupEnvironment(){
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
    }

    function setupLights(){
      ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);

      innerLight = new THREE.PointLight(0xffaa00, 2, 20);
      innerLight.position.set(0, 5, 0);
      mainGroup.add(innerLight);

      spotGold = new THREE.SpotLight(0xffcc66, 1200);
      spotGold.position.set(30, 40, 40);
      spotGold.angle = 0.5;
      spotGold.penumbra = 0.5;
      scene.add(spotGold);

      spotBlue = new THREE.SpotLight(0x6688ff, 600);
      spotBlue.position.set(-30, 20, -30);
      scene.add(spotBlue);

      fill = new THREE.DirectionalLight(0xffeebb, 0.8);
      fill.position.set(0, 0, 50);
      scene.add(fill);
    }

    function setupPostProcessing(){
      const renderScene = new RenderPass(scene, camera);
      bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5, 0.4, 0.85
      );
      bloomPass.threshold = 0.7;
      bloomPass.strength = 0.45;
      bloomPass.radius = 0.4;

      composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);
    }

    function createTextures(){
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,128,128);
      ctx.fillStyle = '#880000';
      ctx.beginPath();
      for(let i=-128;i<256;i+=32){
        ctx.moveTo(i,0);
        ctx.lineTo(i+32,128);
        ctx.lineTo(i+16,128);
        ctx.lineTo(i-16,0);
      }
      ctx.fill();

      caneTexture = new THREE.CanvasTexture(canvas);
      caneTexture.wrapS = THREE.RepeatWrapping;
      caneTexture.wrapT = THREE.RepeatWrapping;
      caneTexture.repeat.set(3,3);
    }

    class Particle {
      constructor(mesh, type, isDust=false){
        this.mesh = mesh;
        this.type = type;
        this.isDust = isDust;

        this.posTree = new THREE.Vector3();
        this.posScatter = new THREE.Vector3();
        this.baseScale = mesh.scale.x;

        const speedMult = (type === 'PHOTO') ? 0.25 : 2.0;
        this.spinSpeed = new THREE.Vector3(
          (Math.random()-0.5)*speedMult,
          (Math.random()-0.5)*speedMult,
          (Math.random()-0.5)*speedMult
        );

        this.calculatePositions();
      }

      calculatePositions(){
        const h = CONFIG.particles.treeHeight;
        const halfH = h/2;

        let t = Math.random();
        t = Math.pow(t, 0.8);
        const y = (t*h) - halfH;

        let rMax = CONFIG.particles.treeRadius * (1.0 - t);
        if (rMax < 0.5) rMax = 0.5;

        const angle = t * 50 * Math.PI + Math.random() * Math.PI;
        const r = rMax * (0.8 + Math.random()*0.4);
        this.posTree.set(Math.cos(angle)*r, y, Math.sin(angle)*r);

        let rScatter = this.isDust ? (12 + Math.random()*20) : (8 + Math.random()*12);
        const theta = Math.random()*Math.PI*2;
        const phi = Math.acos(2*Math.random()-1);
        this.posScatter.set(
          rScatter*Math.sin(phi)*Math.cos(theta),
          rScatter*Math.sin(phi)*Math.sin(theta),
          rScatter*Math.cos(phi)
        );
      }

      update(dt, mode, focusTargetMesh){
        let target = this.posTree;

        if (mode === 'SCATTER') target = this.posScatter;
        else if (mode === 'FOCUS') {
          if (this.mesh === focusTargetMesh) {
            const desiredWorldPos = new THREE.Vector3(0, 2, 35);
            const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
            target = desiredWorldPos.applyMatrix4(invMatrix);
          } else {
            target = this.posScatter;
          }
        }

        const lerpSpeed = (mode === 'FOCUS' && this.mesh === focusTargetMesh) ? 6.0 : 2.4;
        this.mesh.position.lerp(target, lerpSpeed * dt);

        if (mode === 'SCATTER') {
          this.mesh.rotation.x += this.spinSpeed.x * dt;
          this.mesh.rotation.y += this.spinSpeed.y * dt;
          this.mesh.rotation.z += this.spinSpeed.z * dt;
        } else if (mode === 'TREE') {
          this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt);
          this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt);
          this.mesh.rotation.y += 0.5 * dt;
        }

        if (mode === 'FOCUS' && this.mesh === focusTargetMesh) {
          this.mesh.lookAt(camera.position);
        }

        let s = this.baseScale;

        if (this.isDust) {
          s = this.baseScale * (0.8 + 0.4*Math.sin(clock.elapsedTime*4 + this.mesh.id));
          if (mode === 'TREE') s = 0;
        } else if (mode === 'SCATTER' && this.type === 'PHOTO') {
          s = this.baseScale * 2.2;
        } else if (mode === 'FOCUS') {
          if (this.mesh === focusTargetMesh) s = 4.6;
          else s = this.baseScale * 0.85;
        }

        this.mesh.scale.lerp(new THREE.Vector3(s,s,s), 4*dt);
      }
    }

    function createParticles(){
      const sphereGeo = new THREE.SphereGeometry(0.5, 26, 26);
      const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55);

      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0,-0.5,0), new THREE.Vector3(0,0.3,0),
        new THREE.Vector3(0.1,0.5,0), new THREE.Vector3(0.3,0.4,0)
      ]);
      const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false);

      const goldMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.champagneGold,
        metalness: 1.0, roughness: 0.1,
        envMapIntensity: 2.0,
        emissive: 0x443300,
        emissiveIntensity: 0.3
      });

      const greenMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.deepGreen,
        metalness: 0.2, roughness: 0.8,
        emissive: 0x002200,
        emissiveIntensity: 0.2
      });

      const redMat = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.accentRed,
        metalness: 0.3, roughness: 0.2, clearcoat: 1.0,
        emissive: 0x330000
      });

      const candyMat = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.4 });

      for(let i=0;i<CONFIG.particles.count;i++){
        const rand = Math.random();
        let mesh, type;

        if (rand < 0.40) { mesh = new THREE.Mesh(boxGeo, greenMat); type='BOX'; }
        else if (rand < 0.70) { mesh = new THREE.Mesh(boxGeo, goldMat); type='GOLD_BOX'; }
        else if (rand < 0.92) { mesh = new THREE.Mesh(sphereGeo, goldMat); type='GOLD_SPHERE'; }
        else if (rand < 0.97) { mesh = new THREE.Mesh(sphereGeo, redMat); type='RED'; }
        else { mesh = new THREE.Mesh(candyGeo, candyMat); type='CANE'; }

        const s = 0.4 + Math.random()*0.5;
        mesh.scale.set(s,s,s);
        mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);

        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, type, false));
      }

      const starGeo = new THREE.OctahedronGeometry(1.2, 0);
      const starMat = new THREE.MeshStandardMaterial({
        color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 1.0,
        metalness: 1.0, roughness: 0
      });
      const star = new THREE.Mesh(starGeo, starMat);
      star.position.set(0, CONFIG.particles.treeHeight/2 + 1.2, 0);
      mainGroup.add(star);
    }

    function createDust(){
      const geo = new THREE.TetrahedronGeometry(0.08, 0);
      const mat = new THREE.MeshBasicMaterial({ color:0xffeebb, transparent:true, opacity:0.78 });

      for(let i=0;i<CONFIG.particles.dustCount;i++){
        const mesh = new THREE.Mesh(geo, mat);
        mesh.scale.setScalar(0.5 + Math.random());
        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, 'DUST', true));
      }
    }

    function addPhotoToScene(texture){
      const frameGeo = new THREE.BoxGeometry(1.4, 1.4, 0.05);
      const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.champagneGold, metalness:1.0, roughness:0.1 });
      const frame = new THREE.Mesh(frameGeo, frameMat);

      const photoGeo = new THREE.PlaneGeometry(1.2, 1.2);
      const photoMat = new THREE.MeshBasicMaterial({ map:texture });
      const photo = new THREE.Mesh(photoGeo, photoMat);
      photo.position.z = 0.04;

      const group = new THREE.Group();
      group.userData.isPhotoGroup = true;
      group.add(frame);
      group.add(photo);

      group.scale.set(0.8,0.8,0.8);

      photoMeshGroup.add(group);
      particleSystem.push(new Particle(group, 'PHOTO', false));
    }

    function handleImageUpload(e){
      const files = e.target.files;
      if(!files || !files.length) return;
      Array.from(files).forEach(f => {
        const reader = new FileReader();
        reader.onload = (ev) => {
          new THREE.TextureLoader().load(ev.target.result, (t) => {
            t.colorSpace = THREE.SRGBColorSpace;
            addPhotoToScene(t);
            setStatus("ƒê√£ th√™m ·∫£nh ‚úÖ ‚Ä¢ Tap/click ·∫£nh ƒë·ªÉ focus");
          });
        };
        reader.readAsDataURL(f);
      });
    }

    // ---------- Snow ----------
    function createSnow(){
      const count = CONFIG.snow.count;
      const area = CONFIG.snow.area;

      snowGeo = new THREE.BufferGeometry();
      const positions = new Float32Array(count*3);
      snowVel = new Float32Array(count*3);

      for(let i=0;i<count;i++){
        const ix = i*3;
        positions[ix+0] = (Math.random()-0.5)*area;
        positions[ix+1] = (Math.random()*area*0.9) - (area*0.2);
        positions[ix+2] = (Math.random()-0.5)*area;

        snowVel[ix+0] = (Math.random()-0.5)*CONFIG.snow.drift;
        snowVel[ix+1] = -(CONFIG.snow.fallSpeed*(0.6 + Math.random()*0.8));
        snowVel[ix+2] = (Math.random()-0.5)*CONFIG.snow.drift;
      }

      snowGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

      const snowMat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: isMobile ? 0.14 : 0.12,
        transparent: true,
        opacity: 0.75,
        depthWrite: false
      });

      snowPoints = new THREE.Points(snowGeo, snowMat);
      scene.add(snowPoints);
      STATE.snowOn = true;
    }

    function updateSnow(dt){
      if(!snowPoints || !STATE.snowOn) return;

      const area = CONFIG.snow.area;
      const pos = snowGeo.attributes.position.array;

      for(let i=0;i<CONFIG.snow.count;i++){
        const ix = i*3;
        pos[ix+0] += snowVel[ix+0]*dt;
        pos[ix+1] += snowVel[ix+1]*dt;
        pos[ix+2] += snowVel[ix+2]*dt;

        if (pos[ix+1] < -area*0.6) {
          pos[ix+1] = area*0.6;
          pos[ix+0] = (Math.random()-0.5)*area;
          pos[ix+2] = (Math.random()-0.5)*area;
        }
      }
      snowGeo.attributes.position.needsUpdate = true;
    }

    // ---------- Audio ----------
    async function ensureAudioGraph(){
      if(STATE.audioReady) return true;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 1024;
        analyser.smoothingTimeConstant = 0.85;

        sourceNode = audioCtx.createMediaElementSource(audioEl);
        sourceNode.connect(analyser);
        analyser.connect(audioCtx.destination);

        freqData = new Uint8Array(analyser.frequencyBinCount);
        STATE.audioReady = true;
        return true;
      } catch (e) {
        console.warn("Audio init fail:", e);
        setStatus("Kh√¥ng b·∫≠t ƒë∆∞·ª£c audio analyzer. B·∫°n v·∫´n d√πng hi·ªáu ·ª©ng b√¨nh th∆∞·ªùng.");
        return false;
      }
    }

    function getBeatLevel(){
      if(!STATE.audioReady || !analyser || !freqData || audioEl.paused) return 0;
      analyser.getByteFrequencyData(freqData);

      let sum = 0;
      const from = Math.floor(freqData.length*0.02);
      const to   = Math.floor(freqData.length*0.18);
      for(let i=from;i<to;i++) sum += freqData[i];
      const avg = sum / (to-from) / 255;
      return avg;
    }

    function applyAudioReactive(dt){
      const raw = getBeatLevel();
      STATE.beat += (raw - STATE.beat) * (6.0 * dt);
      const b = STATE.beat;

      innerLight.intensity = 1.7 + b*3.0;
      spotGold.intensity   = 950 + b*700;
      spotBlue.intensity   = 450 + b*550;
      ambient.intensity    = 0.55 + b*0.25;

      bloomPass.strength = 0.38 + b*0.22;

      const h = (0.10 + b*0.06) % 1;
      spotGold.color.setHSL(h, 0.65, 0.55);
    }

    async function playPauseMusic(){
      const ok = await ensureAudioGraph();
      if(!ok) return;

      if (audioCtx.state === "suspended") await audioCtx.resume();

      if(!audioEl.src){
        setStatus("B·∫°n ch∆∞a upload nh·∫°c üéµ (b·∫•m ‚¨ÜÔ∏è NH·∫†C ƒë·ªÉ ch·ªçn file mp3).");
        return;
      }

      if(audioEl.paused){
        try{
          await audioEl.play();
          STATE.musicOn = true;
          $("#btn-music").textContent = "üé∂ Nh·∫°c: B·∫≠t";
          const mp = document.getElementById("m-play");
          if(mp) mp.textContent = "‚è∏Ô∏è D·ª™NG";
          setStatus("Nh·∫°c ƒëang ph√°t üé∂");
        }catch(e){
          setStatus("iPhone ch·∫∑n autoplay. B·∫•m l·∫°i n√∫t PH√ÅT ƒë·ªÉ b·∫≠t.");
        }
      } else {
        audioEl.pause();
        STATE.musicOn = false;
        $("#btn-music").textContent = "üé∂ Nh·∫°c: T·∫Øt";
        const mp = document.getElementById("m-play");
        if(mp) mp.textContent = "üéµ PH√ÅT";
        setStatus("Nh·∫°c ƒë√£ t·∫Øt.");
      }
    }

    function handleAudioUpload(e){
      const file = e.target.files?.[0];
      if(!file) return;
      const url = URL.createObjectURL(file);
      audioEl.src = url;
      audioEl.loop = true;
      audioEl.volume = 0.7;
      setStatus(`ƒê√£ load nh·∫°c: ${file.name} ‚úÖ ‚Ä¢ B·∫•m PH√ÅT ƒë·ªÉ nghe`);
    }

    // ---------- Mode ----------
    function setMode(mode, opts = {}){
      STATE.modeTarget = mode;

      if (mode !== 'FOCUS') {
        STATE.focusTarget = null;
        setTitle("NOEL");
      } else {
        const photos = particleSystem.filter(p => p.type === 'PHOTO');
        if (opts.targetMesh) STATE.focusTarget = opts.targetMesh;
        else STATE.focusTarget = photos.length ? photos[Math.floor(Math.random()*photos.length)].mesh : null;
        if (STATE.focusTarget) setTitle(randomGreeting());
      }

      $("#btn-mode").textContent = `üîÅ Mode: ${STATE.modeTarget}`;
      const mb = document.getElementById("m-mode");
      if (mb) mb.textContent = (STATE.modeTarget === 'TREE') ? "üå≤ TREE"
                         : (STATE.modeTarget === 'SCATTER') ? "ü™ê SCATTER"
                         : "üîé FOCUS";
    }

    function cycleMode(){
      const next = (STATE.modeTarget === 'TREE') ? 'SCATTER' : (STATE.modeTarget === 'SCATTER' ? 'FOCUS' : 'TREE');
      setMode(next);
    }

    // ---------- Click pick photo ----------
    function updatePointerFromEvent(ev){
      const rect = renderer.domElement.getBoundingClientRect();
      const x = (ev.clientX - rect.left) / rect.width;
      const y = (ev.clientY - rect.top) / rect.height;
      pointer.x = x*2 - 1;
      pointer.y = -(y*2 - 1);
    }

    function tryPickPhoto(ev){
      updatePointerFromEvent(ev);
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(photoMeshGroup.children, true);
      if(!hits.length) return false;

      let obj = hits[0].object;
      while(obj && !obj.userData?.isPhotoGroup) obj = obj.parent;
      if(!obj) return false;

      setMode('FOCUS', { targetMesh: obj });
      setStatus("FOCUS ‚úÖ ‚Ä¢ Tap ·∫£nh kh√°c ƒë·ªÉ ƒë·ªïi");
      return true;
    }

    function setupEvents(){
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      // desktop buttons
      $("#btn-music").addEventListener('click', playPauseMusic);
      $("#btn-snow").addEventListener('click', () => {
        STATE.snowOn = !STATE.snowOn;
        $("#btn-snow").textContent = `‚ùÑÔ∏è Tuy·∫øt: ${STATE.snowOn ? "B·∫≠t" : "T·∫Øt"}`;
        const ms = document.getElementById("m-snow");
        if(ms) ms.textContent = STATE.snowOn ? "‚ùÑÔ∏è TUY·∫æT" : "üåô TUY·∫æT";
      });
      $("#btn-mode").addEventListener('click', cycleMode);
      $("#btn-ui").addEventListener('click', toggleUI);

      // inputs
      $("#file-input").addEventListener('change', handleImageUpload);
      $("#audio-input").addEventListener('change', handleAudioUpload);

      // mobile buttons
      document.getElementById("m-toggle-ui")?.addEventListener("click", toggleUI);
      document.getElementById("m-add-photo")?.addEventListener("click", () => {
        document.getElementById("file-input")?.click();
      });
      document.getElementById("m-upload-audio")?.addEventListener("click", () => {
        document.getElementById("audio-input")?.click();
      });
      document.getElementById("m-mode")?.addEventListener("click", cycleMode);
      document.getElementById("m-snow")?.addEventListener("click", () => {
        STATE.snowOn = !STATE.snowOn;
        $("#btn-snow").textContent = `‚ùÑÔ∏è Tuy·∫øt: ${STATE.snowOn ? "B·∫≠t" : "T·∫Øt"}`;
        const ms = document.getElementById("m-snow");
        if(ms) ms.textContent = STATE.snowOn ? "‚ùÑÔ∏è TUY·∫æT" : "üåô TUY·∫æT";
      });
      document.getElementById("m-play")?.addEventListener("click", playPauseMusic);

      // click focus photo
      renderer.domElement.addEventListener('click', (ev) => {
        tryPickPhoto(ev);
      });

      // pointer drag rotate (desktop)
      let isDown = false, lastX = 0, lastY = 0;
      renderer.domElement.addEventListener('pointerdown', (ev) => {
        isDown = true;
        lastX = ev.clientX; lastY = ev.clientY;
      });
      window.addEventListener('pointerup', () => { isDown = false; });
      window.addEventListener('pointermove', (ev) => {
        if(!isDown) return;
        const dx = ev.clientX - lastX;
        const dy = ev.clientY - lastY;
        lastX = ev.clientX; lastY = ev.clientY;

        STATE.rotationTarget.y += dx * 0.006;
        STATE.rotationTarget.x += dy * 0.0025;
        STATE.rotationTarget.x = THREE.MathUtils.clamp(STATE.rotationTarget.x, -0.65, 0.65);
      });

      // touch gestures (mobile)
      let lastTap = 0;
      let pinchStartDist = 0;
      let camStartZ = camera.position.z;
      let swipeStartX = 0, swipeStartY = 0;
      let touchLastX = 0, touchLastY = 0;
      let pinching = false;

      function dist2(t1,t2){
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.hypot(dx,dy);
      }

      renderer.domElement.addEventListener('touchstart', (e) => {
        if(!isMobile) return;
        if(e.touches.length === 1){
          const now = Date.now();
          if(now - lastTap < 280){
            setMode('FOCUS');
          }
          lastTap = now;

          touchLastX = e.touches[0].clientX;
          touchLastY = e.touches[0].clientY;
          swipeStartX = touchLastX;
          swipeStartY = touchLastY;
          pinching = false;
        } else if(e.touches.length === 2){
          pinching = true;
          pinchStartDist = dist2(e.touches[0], e.touches[1]);
          camStartZ = camera.position.z;
        }
      }, { passive:true });

      renderer.domElement.addEventListener('touchmove', (e) => {
        if(!isMobile) return;

        if(e.touches.length === 1 && !pinching){
          const x = e.touches[0].clientX;
          const y = e.touches[0].clientY;
          const dx = x - touchLastX;
          const dy = y - touchLastY;
          touchLastX = x; touchLastY = y;

          STATE.rotationTarget.y += dx * 0.0065;
          STATE.rotationTarget.x += dy * 0.0028;
          STATE.rotationTarget.x = THREE.MathUtils.clamp(STATE.rotationTarget.x, -0.65, 0.65);

        } else if(e.touches.length === 2){
          const d = dist2(e.touches[0], e.touches[1]);
          const scale = d / Math.max(1, pinchStartDist);
          const nextZ = camStartZ / scale;
          camera.position.z = THREE.MathUtils.clamp(nextZ, 28, 80);
        }
      }, { passive:true });

      renderer.domElement.addEventListener('touchend', (e) => {
        if(!isMobile) return;
        if(e.touches.length > 0) return;

        const ct = e.changedTouches?.[0];
        if(!ct) return;
        const dx = ct.clientX - swipeStartX;
        const dy = ct.clientY - swipeStartY;

        if(Math.abs(dx) > 70 && Math.abs(dx) > Math.abs(dy)*1.2){
          if(dx > 0) setMode('TREE');
          else setMode('SCATTER');
        }

        pinching = false;
      }, { passive:true });

      // keyboard
      window.addEventListener('keydown', async (e) => {
        const k = e.key.toLowerCase();
        if (k === 'h') toggleUI();
        if (k === '1') setMode('TREE');
        if (k === '2') setMode('SCATTER');
        if (k === '3') setMode('FOCUS');
        if (k === 's') {
          STATE.snowOn = !STATE.snowOn;
          $("#btn-snow").textContent = `‚ùÑÔ∏è Tuy·∫øt: ${STATE.snowOn ? "B·∫≠t" : "T·∫Øt"}`;
        }
        if (k === ' ') {
          e.preventDefault();
          await playPauseMusic();
        }
      });
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);

      if (STATE.mode !== STATE.modeTarget) {
        STATE.mode = STATE.modeTarget;
      }

      if (STATE.mode === 'TREE') {
        STATE.rotationTarget.y += 0.3 * dt;
        STATE.rotationTarget.x += (0 - STATE.rotationTarget.x) * 2.0 * dt;
      } else {
        STATE.rotationTarget.y += 0.1 * dt;
        STATE.rotationTarget.x += (0 - STATE.rotationTarget.x) * 1.2 * dt;
      }

      STATE.rotation.y += (STATE.rotationTarget.y - STATE.rotation.y) * 3.0 * dt;
      STATE.rotation.x += (STATE.rotationTarget.x - STATE.rotation.x) * 3.0 * dt;

      mainGroup.rotation.y = STATE.rotation.y;
      mainGroup.rotation.x = STATE.rotation.x;

      particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));

      updateSnow(dt);
      applyAudioReactive(dt);

      composer.render();
    }

    init();
  </script>
  <!-- üéµ Nh·∫°c Noel m·∫∑c ƒë·ªãnh -->
<audio id="bgm" src="./noel.mp3" loop preload="auto"></audio>
<script>
  const bgm = document.getElementById("bgm");
  let musicOn = false;

  function toggleMusic() {
    if (!musicOn) {
      bgm.play();
      musicOn = true;
    } else {
      bgm.pause();
      musicOn = false;
    }
  }
</script>
</body>
</html>

