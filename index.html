<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Noel 3D</title>

  <style>
    body{ margin:0; overflow:hidden; background:#000; font-family:"Times New Roman", serif; }
    #canvas-container{ position:absolute; inset:0; z-index:1; }

    #loader{
      position:absolute; inset:0; z-index:100;
      background:#000; display:flex; flex-direction:column;
      align-items:center; justify-content:center;
      transition:opacity .8s ease-out;
    }
    .spinner{
      width:40px; height:40px; border-radius:50%;
      border:1px solid rgba(212,175,55,.2);
      border-top:1px solid #d4af37;
      animation:spin 1s linear infinite;
    }
    @keyframes spin{ from{transform:rotate(0)} to{transform:rotate(360deg)} }
    .loader-text{
      color:#d4af37; margin-top:18px; letter-spacing:4px; font-size:12px;
      text-transform:uppercase; opacity:.9;
    }

    /* UI layer (desktop + common) */
    #ui-layer{
      position:absolute; inset:0; z-index:10;
      pointer-events:none;
      display:flex; flex-direction:column; align-items:center;
      padding-top:28px; box-sizing:border-box;
      transition:opacity .22s ease;
    }
    h1{
      margin:0; padding:0 14px;
      font-size:52px; font-weight:400; letter-spacing:6px;
      font-family:'Cinzel','Times New Roman',serif;
      background:linear-gradient(to bottom,#fff,#eebb66);
      -webkit-background-clip:text; -webkit-text-fill-color:transparent;
      text-shadow:0 0 40px rgba(252,238,167,.45);
      opacity:.92;
      text-align:center;
    }
    #subtitle{
      margin-top:10px; padding:0 14px;
      font-size:12px; letter-spacing:1px;
      color:rgba(255,255,255,.72);
      text-transform:uppercase;
      text-align:center;
      transition:opacity .22s ease;
    }

    .controls{
      margin-top:16px; padding:0 14px;
      display:flex; flex-wrap:wrap; gap:10px;
      justify-content:center; align-items:center;
      pointer-events:auto;
      transition:opacity .22s ease;
    }
    .btn{
      display:inline-flex; align-items:center; gap:8px;
      background:rgba(20,20,20,.6);
      border:1px solid rgba(212,175,55,.35);
      color:#d4af37;
      padding:10px 14px;
      border-radius:999px;
      cursor:pointer;
      text-transform:uppercase;
      letter-spacing:2px;
      font-size:10px;
      user-select:none;
      backdrop-filter: blur(6px);
      transition:all .22s ease;
    }
    .btn:hover{ background:#d4af37; color:#000; box-shadow:0 0 18px rgba(212,175,55,.35); }
    .btn.secondary{
      border-color: rgba(255,255,255,.14);
      color: rgba(255,255,255,.9);
    }
    .btn.secondary:hover{ background:rgba(255,255,255,.92); color:#000; box-shadow:0 0 18px rgba(255,255,255,.22); }
    .btn input{ display:none; }

    #hint{
      margin-top:10px; padding:0 14px;
      color:rgba(212,175,55,.55);
      font-size:9px; letter-spacing:1px;
      text-transform:uppercase;
      text-align:center;
      transition:opacity .22s ease;
    }
    #status{
      margin-top:12px;
      padding:7px 11px;
      border-radius:999px;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.08);
      color:rgba(255,255,255,.7);
      font-size:11px;
      letter-spacing:1px;
      backdrop-filter: blur(6px);
      max-width:min(560px,92vw);
      text-align:center;
      pointer-events:none;
      transition:opacity .22s ease;
      line-height:1.35;
    }

    /* Hide ALL UI (3 lines) when ui-off */
    .ui-off #ui-layer{ opacity:0; pointer-events:none; }
    .ui-off #appbar{ opacity:0; pointer-events:none; }

    /* Mobile appbar */
    #appbar{ display:none; }
    @media (max-width: 768px){
      #controls, #hint{ display:none !important; }
      #subtitle{ font-size:11px; opacity:.85; }
      #appbar{
        display:flex;
        position:fixed;
        left:12px; right:12px; bottom:14px;
        z-index:50;
        gap:10px;
        padding:10px 12px;
        border-radius:18px;
        background:rgba(0,0,0,.45);
        border:1px solid rgba(255,255,255,.10);
        backdrop-filter: blur(10px);
        align-items:center; justify-content:space-between;
        pointer-events:auto;
        transition: opacity .22s ease;
      }
      .appbtn{
        flex:1;
        border:1px solid rgba(255,255,255,.12);
        background: rgba(255,255,255,.06);
        color: rgba(255,255,255,.92);
        padding: 10px 10px;
        border-radius: 14px;
        font-size: 12px;
        letter-spacing: .5px;
        text-transform: uppercase;
        cursor: pointer;
        user-select: none;
      }
      .appbtn.primary{
        border-color: rgba(212,175,55,.35);
        background: rgba(212,175,55,.18);
        color: #f7e6a6;
      }
      .appbtn:active{ transform:scale(.98); }
    }

    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div id="loader">
    <div class="spinner"></div>
    <div class="loader-text">Loading Holiday Magic</div>
  </div>

  <div id="canvas-container"></div>

  <div id="ui-layer">
    <h1 id="title">NOEL</h1>
    <div id="subtitle">Mobile: 1 ng√≥n xoay ‚Ä¢ 2 ng√≥n zoom ‚Ä¢ double tap focus ‚Ä¢ swipe ƒë·ªïi mode</div>

    <!-- Desktop Controls -->
    <div class="controls" id="controls">
      <label class="btn">
        üñºÔ∏è Th√™m ·∫£nh
        <input type="file" id="file-input" multiple accept="image/*" />
      </label>

      <button class="btn" id="btn-music">üéµ Nh·∫°c: T·∫Øt</button>
      <button class="btn secondary" id="btn-snow">‚ùÑÔ∏è Tuy·∫øt: B·∫≠t</button>
      <button class="btn secondary" id="btn-mode">üîÅ Mode: TREE</button>
      <button class="btn secondary" id="btn-ui">üôà ·∫®n UI</button>
    </div>

    <div id="hint">PC: 1=Tree ‚Ä¢ 2=Scatter ‚Ä¢ 3=Focus ‚Ä¢ ESC=Tho√°t ‚Ä¢ Space=Nh·∫°c ‚Ä¢ S=Tuy·∫øt ‚Ä¢ H=·∫®n UI</div>
    <div id="status">Upload file <b>noel.mp3</b> (c√πng ch·ªó index.html). iPhone ch·ªâ ph√°t nh·∫°c sau khi b·∫•m n√∫t üéµ.</div>
  </div>

  <!-- Mobile App Bar -->
  <div id="appbar">
    <button class="appbtn" id="m-ui">üôà UI</button>
    <button class="appbtn" id="m-photo">üñºÔ∏è ·∫¢NH</button>
    <button class="appbtn primary" id="m-mode">üå≤ TREE</button>
    <button class="appbtn" id="m-snow">‚ùÑÔ∏è TUY·∫æT</button>
    <button class="appbtn" id="m-play">üéµ PH√ÅT</button>
  </div>

  <!-- ‚úÖ Nh·∫°c m·∫∑c ƒë·ªãnh (c·∫ßn file noel.mp3 c√πng th∆∞ m·ª•c) -->
  <audio id="bgm" src="./noel.mp3" preload="auto" playsinline></audio>

  <script type="module">
    import * as THREE from "three";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";

    const $ = (s) => document.querySelector(s);

    const titleEl = $("#title");
    const statusEl = $("#status");
    const isMobile =
      matchMedia("(max-width: 768px)").matches ||
      /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    const DPR = Math.min(window.devicePixelRatio || 1, isMobile ? 1.6 : 2.0);

    const GREETINGS = [
      "Merry Christmas ‚ú®",
      "Gi√°ng Sinh An L√†nh üéÑ",
      "An Nhi√™n & ·∫§m √Åp ü§ç",
      "Ch√∫c B·∫°n Vui V·∫ª üéÅ",
      "H·∫°nh Ph√∫c Ng·∫≠p Tr√†n ‚ú®",
      "Peace ‚Ä¢ Love ‚Ä¢ Joy üïØÔ∏è",
      "Noel Vui V·∫ª ü•Ç",
      "Th·∫≠t Nhi·ªÅu May M·∫Øn ‚≠ê"
    ];
    const randomGreeting = () => GREETINGS[Math.floor(Math.random() * GREETINGS.length)];

    function setStatus(t) { statusEl.innerHTML = t; }
    function setTitle(t) { titleEl.textContent = t; }

    // ====== STATE ======
    const STATE = {
      mode: "TREE",
      modeTarget: "TREE",
      focusTarget: null,

      rotation: { x: 0, y: 0 },
      rotationTarget: { x: 0, y: 0 },

      snowOn: true,
      musicOn: false
    };

    // ====== AUDIO (iPhone safe) ======
    const bgm = document.getElementById("bgm");
    let audioUnlocked = false;

    function updateMusicButtons() {
      $("#btn-music").textContent = STATE.musicOn ? "üéµ Nh·∫°c: B·∫≠t" : "üéµ Nh·∫°c: T·∫Øt";
      const mp = document.getElementById("m-play");
      if (mp) mp.textContent = STATE.musicOn ? "‚è∏Ô∏è D·ª™NG" : "üéµ PH√ÅT";
    }

    async function unlockAudioOnce() {
      if (audioUnlocked) return;
      try {
        // iOS unlock trick: play muted once
        bgm.muted = true;
        await bgm.play();
        bgm.pause();
        bgm.currentTime = 0;
        bgm.muted = false;
        audioUnlocked = true;
      } catch (e) {
        audioUnlocked = false;
      }
    }

    async function toggleMusic() {
      try {
        await unlockAudioOnce();

        bgm.loop = true;
        bgm.volume = 1;
        // help Safari re-check stream
        bgm.load();

        if (!STATE.musicOn) {
          await bgm.play();
          STATE.musicOn = true;
          setStatus("Nh·∫°c ƒëang ph√°t üé∂");
        } else {
          bgm.pause();
          STATE.musicOn = false;
          setStatus("Nh·∫°c ƒë√£ t·∫Øt.");
        }
        updateMusicButtons();
      } catch (e) {
        console.log(e);
        setStatus("Kh√¥ng ph√°t ƒë∆∞·ª£c nh·∫°c. H√£y th·ª≠ b·∫•m üéµ th√™m 1 l·∫ßn. (iPhone c·∫ßn thao t√°c ƒë·ªÉ m·ªü kh√≥a √¢m thanh)");
      }
    }

    // expose for inline safety (optional)
    window.toggleMusic = toggleMusic;

    // ====== THREE CONFIG ======
    const CONFIG = {
      colors: { bg: 0x000000, gold: 0xffd966, green: 0x03180a, red: 0x990000 },
      particles: {
        count: isMobile ? 900 : 1500,
        dustCount: isMobile ? 1400 : 2500,
        treeHeight: 24,
        treeRadius: 8
      },
      snow: { count: isMobile ? 900 : 1800, area: 60, fallSpeed: 8.5, drift: 1.2 },
      camera: { z: 50 }
    };

    let scene, camera, renderer, composer, mainGroup;
    let clock = new THREE.Clock();
    let particleSystem = [];
    let photoMeshGroup = new THREE.Group();

    // snow
    let snowPoints = null, snowGeo = null, snowVel = null;

    // raycast
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    class Particle {
      constructor(mesh, type, isDust = false) {
        this.mesh = mesh;
        this.type = type;
        this.isDust = isDust;

        this.posTree = new THREE.Vector3();
        this.posScatter = new THREE.Vector3();
        this.baseScale = mesh.scale.x;

        const speedMult = type === "PHOTO" ? 0.25 : 2.0;
        this.spinSpeed = new THREE.Vector3(
          (Math.random() - 0.5) * speedMult,
          (Math.random() - 0.5) * speedMult,
          (Math.random() - 0.5) * speedMult
        );

        this.calculatePositions();
      }

      calculatePositions() {
        const h = CONFIG.particles.treeHeight;
        const halfH = h / 2;

        let t = Math.pow(Math.random(), 0.8);
        const y = t * h - halfH;

        let rMax = CONFIG.particles.treeRadius * (1 - t);
        if (rMax < 0.5) rMax = 0.5;

        const angle = t * 50 * Math.PI + Math.random() * Math.PI;
        const r = rMax * (0.8 + Math.random() * 0.4);
        this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);

        const rScatter = this.isDust ? 12 + Math.random() * 20 : 8 + Math.random() * 12;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        this.posScatter.set(
          rScatter * Math.sin(phi) * Math.cos(theta),
          rScatter * Math.sin(phi) * Math.sin(theta),
          rScatter * Math.cos(phi)
        );
      }

      update(dt, mode, focusTargetMesh) {
        let target = this.posTree;
        if (mode === "SCATTER") target = this.posScatter;
        else if (mode === "FOCUS") {
          if (this.mesh === focusTargetMesh) {
            const desired = new THREE.Vector3(0, 2, 35);
            const inv = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
            target = desired.applyMatrix4(inv);
          } else {
            target = this.posScatter;
          }
        }

        const lerpSpeed = mode === "FOCUS" && this.mesh === focusTargetMesh ? 6.0 : 2.4;
        this.mesh.position.lerp(target, lerpSpeed * dt);

        if (mode === "SCATTER") {
          this.mesh.rotation.x += this.spinSpeed.x * dt;
          this.mesh.rotation.y += this.spinSpeed.y * dt;
          this.mesh.rotation.z += this.spinSpeed.z * dt;
        } else if (mode === "TREE") {
          this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt);
          this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt);
          this.mesh.rotation.y += 0.5 * dt;
        }

        if (mode === "FOCUS" && this.mesh === focusTargetMesh) this.mesh.lookAt(camera.position);

        let s = this.baseScale;
        if (this.isDust) {
          s = this.baseScale * (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id));
          if (mode === "TREE") s = 0;
        } else if (mode === "SCATTER" && this.type === "PHOTO") {
          s = this.baseScale * 2.2;
        } else if (mode === "FOCUS") {
          s = this.mesh === focusTargetMesh ? 4.6 : this.baseScale * 0.85;
        }

        this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 4 * dt);
      }
    }

    function initThree() {
      const container = $("#canvas-container");

      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.colors.bg);
      scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.01);

      camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, CONFIG.camera.z);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(DPR);
      renderer.toneMapping = THREE.ReinhardToneMapping;
      renderer.toneMappingExposure = 2.2;

      container.appendChild(renderer.domElement);

      mainGroup = new THREE.Group();
      scene.add(mainGroup);

      mainGroup.add(photoMeshGroup);

      const pmrem = new THREE.PMREMGenerator(renderer);
      scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;

      // lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const inner = new THREE.PointLight(0xffaa00, 2, 20);
      inner.position.set(0, 5, 0);
      mainGroup.add(inner);

      const spotGold = new THREE.SpotLight(0xffcc66, 1200);
      spotGold.position.set(30, 40, 40);
      spotGold.angle = 0.5;
      spotGold.penumbra = 0.5;
      scene.add(spotGold);

      const spotBlue = new THREE.SpotLight(0x6688ff, 600);
      spotBlue.position.set(-30, 20, -30);
      scene.add(spotBlue);

      const composerLocal = new EffectComposer(renderer);
      composerLocal.addPass(new RenderPass(scene, camera));
      const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
      bloom.threshold = 0.7;
      bloom.strength = 0.45;
      bloom.radius = 0.4;
      composerLocal.addPass(bloom);

      composer = composerLocal;
    }

    function createParticles() {
      const sphereGeo = new THREE.SphereGeometry(0.5, 26, 26);
      const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55);

      const goldMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.1,
        envMapIntensity: 2.0, emissive: 0x443300, emissiveIntensity: 0.3
      });
      const greenMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.green, metalness: 0.2, roughness: 0.8,
        emissive: 0x002200, emissiveIntensity: 0.2
      });
      const redMat = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.red, metalness: 0.3, roughness: 0.2, clearcoat: 1.0,
        emissive: 0x330000
      });

      for (let i = 0; i < CONFIG.particles.count; i++) {
        const r = Math.random();
        let mesh, type;
        if (r < 0.40) { mesh = new THREE.Mesh(boxGeo, greenMat); type = "BOX"; }
        else if (r < 0.70) { mesh = new THREE.Mesh(boxGeo, goldMat); type = "GOLD_BOX"; }
        else if (r < 0.92) { mesh = new THREE.Mesh(sphereGeo, goldMat); type = "GOLD_SPHERE"; }
        else { mesh = new THREE.Mesh(sphereGeo, redMat); type = "RED"; }

        const s = 0.4 + Math.random() * 0.5;
        mesh.scale.set(s, s, s);
        mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);

        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, type, false));
      }

      const starGeo = new THREE.OctahedronGeometry(1.2, 0);
      const starMat = new THREE.MeshStandardMaterial({
        color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 1.0,
        metalness: 1.0, roughness: 0
      });
      const star = new THREE.Mesh(starGeo, starMat);
      star.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0);
      mainGroup.add(star);
    }

    function createDust() {
      const geo = new THREE.TetrahedronGeometry(0.08, 0);
      const mat = new THREE.MeshBasicMaterial({ color: 0xffeebb, transparent: true, opacity: 0.78 });

      for (let i = 0; i < CONFIG.particles.dustCount; i++) {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.scale.setScalar(0.5 + Math.random());
        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, "DUST", true));
      }
    }

    function createSnow() {
      const count = CONFIG.snow.count;
      const area = CONFIG.snow.area;

      snowGeo = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      snowVel = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        const ix = i * 3;
        pos[ix + 0] = (Math.random() - 0.5) * area;
        pos[ix + 1] = Math.random() * area * 0.9 - area * 0.2;
        pos[ix + 2] = (Math.random() - 0.5) * area;

        snowVel[ix + 0] = (Math.random() - 0.5) * CONFIG.snow.drift;
        snowVel[ix + 1] = -(CONFIG.snow.fallSpeed * (0.6 + Math.random() * 0.8));
        snowVel[ix + 2] = (Math.random() - 0.5) * CONFIG.snow.drift;
      }

      snowGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      const mat = new THREE.PointsMaterial({
        color: 0xffffff, size: isMobile ? 0.14 : 0.12,
        transparent: true, opacity: 0.75, depthWrite: false
      });

      snowPoints = new THREE.Points(snowGeo, mat);
      scene.add(snowPoints);
      STATE.snowOn = true;
    }

    function updateSnow(dt) {
      if (!snowPoints || !STATE.snowOn) return;
      const area = CONFIG.snow.area;
      const pos = snowGeo.attributes.position.array;

      for (let i = 0; i < CONFIG.snow.count; i++) {
        const ix = i * 3;
        pos[ix + 0] += snowVel[ix + 0] * dt;
        pos[ix + 1] += snowVel[ix + 1] * dt;
        pos[ix + 2] += snowVel[ix + 2] * dt;

        if (pos[ix + 1] < -area * 0.6) {
          pos[ix + 1] = area * 0.6;
          pos[ix + 0] = (Math.random() - 0.5) * area;
          pos[ix + 2] = (Math.random() - 0.5) * area;
        }
      }
      snowGeo.attributes.position.needsUpdate = true;
    }

    function addPhotoToScene(texture) {
      const frameGeo = new THREE.BoxGeometry(1.4, 1.4, 0.05);
      const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.1 });
      const frame = new THREE.Mesh(frameGeo, frameMat);

      const photoGeo = new THREE.PlaneGeometry(1.2, 1.2);
      const photoMat = new THREE.MeshBasicMaterial({ map: texture });
      const photo = new THREE.Mesh(photoGeo, photoMat);
      photo.position.z = 0.04;

      const group = new THREE.Group();
      group.userData.isPhotoGroup = true;
      group.add(frame);
      group.add(photo);
      group.scale.set(0.8, 0.8, 0.8);

      photoMeshGroup.add(group);
      particleSystem.push(new Particle(group, "PHOTO", false));
    }

    function handleImageUpload(e) {
      const files = e.target.files;
      if (!files || !files.length) return;

      Array.from(files).forEach((f) => {
        const reader = new FileReader();
        reader.onload = (ev) => {
          new THREE.TextureLoader().load(ev.target.result, (t) => {
            t.colorSpace = THREE.SRGBColorSpace;
            addPhotoToScene(t);
            setStatus("ƒê√£ th√™m ·∫£nh ‚úÖ ‚Ä¢ Tap/click ·∫£nh ƒë·ªÉ focus");
          });
        };
        reader.readAsDataURL(f);
      });
    }

    // ====== MODE ======
    function setMode(mode, opts = {}) {
      STATE.modeTarget = mode;

      if (mode !== "FOCUS") {
        STATE.focusTarget = null;
        setTitle("NOEL");
      } else {
        const photos = particleSystem.filter((p) => p.type === "PHOTO");
        STATE.focusTarget = opts.targetMesh || (photos.length ? photos[Math.floor(Math.random() * photos.length)].mesh : null);
        if (STATE.focusTarget) setTitle(randomGreeting());
      }

      $("#btn-mode").textContent = `üîÅ Mode: ${STATE.modeTarget}`;
      const mb = document.getElementById("m-mode");
      if (mb) {
        mb.textContent =
          STATE.modeTarget === "TREE" ? "üå≤ TREE" :
          STATE.modeTarget === "SCATTER" ? "ü™ê SCATTER" : "üîé FOCUS";
      }
    }

    function cycleMode() {
      const next = STATE.modeTarget === "TREE" ? "SCATTER" : (STATE.modeTarget === "SCATTER" ? "FOCUS" : "TREE");
      setMode(next);
    }

    // ====== UI ======
    function toggleUI() {
      document.body.classList.toggle("ui-off");
      const hidden = document.body.classList.contains("ui-off");
      $("#btn-ui").textContent = hidden ? "üëÄ Hi·ªán UI" : "üôà ·∫®n UI";
      const mui = document.getElementById("m-ui");
      if (mui) mui.textContent = hidden ? "üëÄ UI" : "üôà UI";
    }

    // ====== PICK PHOTO ======
    function updatePointerFromEvent(ev) {
      const rect = renderer.domElement.getBoundingClientRect();
      const x = (ev.clientX - rect.left) / rect.width;
      const y = (ev.clientY - rect.top) / rect.height;
      pointer.x = x * 2 - 1;
      pointer.y = -(y * 2 - 1);
    }

    function tryPickPhoto(ev) {
      updatePointerFromEvent(ev);
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(photoMeshGroup.children, true);
      if (!hits.length) return false;

      let obj = hits[0].object;
      while (obj && !obj.userData?.isPhotoGroup) obj = obj.parent;
      if (!obj) return false;

      setMode("FOCUS", { targetMesh: obj });
      setStatus("FOCUS ‚úÖ ‚Ä¢ Tap ·∫£nh kh√°c ƒë·ªÉ ƒë·ªïi");
      return true;
    }

    // ====== EVENTS ======
    function setupEvents() {
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      // desktop
      $("#file-input").addEventListener("change", handleImageUpload);
      $("#btn-ui").addEventListener("click", toggleUI);
      $("#btn-mode").addEventListener("click", cycleMode);
      $("#btn-snow").addEventListener("click", () => {
        STATE.snowOn = !STATE.snowOn;
        $("#btn-snow").textContent = `‚ùÑÔ∏è Tuy·∫øt: ${STATE.snowOn ? "B·∫≠t" : "T·∫Øt"}`;
      });
      $("#btn-music").addEventListener("click", toggleMusic);

      // mobile appbar
      document.getElementById("m-ui")?.addEventListener("click", toggleUI);
      document.getElementById("m-photo")?.addEventListener("click", () => document.getElementById("file-input")?.click());
      document.getElementById("m-mode")?.addEventListener("click", cycleMode);
      document.getElementById("m-snow")?.addEventListener("click", () => {
        STATE.snowOn = !STATE.snowOn;
        const ms = document.getElementById("m-snow");
        if (ms) ms.textContent = STATE.snowOn ? "‚ùÑÔ∏è TUY·∫æT" : "üåô TUY·∫æT";
        $("#btn-snow").textContent = `‚ùÑÔ∏è Tuy·∫øt: ${STATE.snowOn ? "B·∫≠t" : "T·∫Øt"}`;
      });
      document.getElementById("m-play")?.addEventListener("click", toggleMusic);

      // click/tap pick
      renderer.domElement.addEventListener("click", (ev) => { tryPickPhoto(ev); });

      // pointer drag rotate
      let isDown = false, lastX = 0, lastY = 0;
      renderer.domElement.addEventListener("pointerdown", (ev) => {
        isDown = true; lastX = ev.clientX; lastY = ev.clientY;
      });
      window.addEventListener("pointerup", () => { isDown = false; });
      window.addEventListener("pointermove", (ev) => {
        if (!isDown) return;
        const dx = ev.clientX - lastX;
        const dy = ev.clientY - lastY;
        lastX = ev.clientX; lastY = ev.clientY;
        STATE.rotationTarget.y += dx * 0.006;
        STATE.rotationTarget.x += dy * 0.0025;
        STATE.rotationTarget.x = THREE.MathUtils.clamp(STATE.rotationTarget.x, -0.65, 0.65);
      });

      // touch gestures
      let lastTap = 0;
      let pinchStart = 0;
      let camStartZ = camera.position.z;
      let swipeStartX = 0, swipeStartY = 0;
      let touchLastX = 0, touchLastY = 0;
      let pinching = false;

      const dist2 = (t1, t2) => Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);

      renderer.domElement.addEventListener("touchstart", (e) => {
        if (!isMobile) return;
        if (e.touches.length === 1) {
          const now = Date.now();
          if (now - lastTap < 280) setMode("FOCUS");
          lastTap = now;

          touchLastX = e.touches[0].clientX;
          touchLastY = e.touches[0].clientY;
          swipeStartX = touchLastX; swipeStartY = touchLastY;
          pinching = false;
        } else if (e.touches.length === 2) {
          pinching = true;
          pinchStart = dist2(e.touches[0], e.touches[1]);
          camStartZ = camera.position.z;
        }
      }, { passive: true });

      renderer.domElement.addEventListener("touchmove", (e) => {
        if (!isMobile) return;
        if (e.touches.length === 1 && !pinching) {
          const x = e.touches[0].clientX, y = e.touches[0].clientY;
          const dx = x - touchLastX, dy = y - touchLastY;
          touchLastX = x; touchLastY = y;
          STATE.rotationTarget.y += dx * 0.0065;
          STATE.rotationTarget.x += dy * 0.0028;
          STATE.rotationTarget.x = THREE.MathUtils.clamp(STATE.rotationTarget.x, -0.65, 0.65);
        } else if (e.touches.length === 2) {
          const d = dist2(e.touches[0], e.touches[1]);
          const scale = d / Math.max(1, pinchStart);
          const nextZ = camStartZ / scale;
          camera.position.z = THREE.MathUtils.clamp(nextZ, 28, 80);
        }
      }, { passive: true });

      renderer.domElement.addEventListener("touchend", (e) => {
        if (!isMobile) return;
        if (e.touches.length > 0) return;

        const ct = e.changedTouches?.[0];
        if (!ct) return;
        const dx = ct.clientX - swipeStartX;
        const dy = ct.clientY - swipeStartY;

        // swipe left/right to switch quickly
        if (Math.abs(dx) > 70 && Math.abs(dx) > Math.abs(dy) * 1.2) {
          if (dx > 0) setMode("TREE");
          else setMode("SCATTER");
        }
        pinching = false;
      }, { passive: true });

      // keyboard shortcuts
      window.addEventListener("keydown", async (e) => {
        const k = e.key.toLowerCase();
        if (k === "h") toggleUI();
        if (k === "1") setMode("TREE");
        if (k === "2") setMode("SCATTER");
        if (k === "3") setMode("FOCUS");
        if (k === "s") {
          STATE.snowOn = !STATE.snowOn;
          $("#btn-snow").textContent = `‚ùÑÔ∏è Tuy·∫øt: ${STATE.snowOn ? "B·∫≠t" : "T·∫Øt"}`;
        }
        if (k === " ") {
          e.preventDefault();
          await toggleMusic();
        }
        if (k === "escape") {
          setMode("TREE");
        }
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);

      // mode sync
      if (STATE.mode !== STATE.modeTarget) STATE.mode = STATE.modeTarget;

      // gentle auto rotate in TREE
      if (STATE.mode === "TREE") {
        STATE.rotationTarget.y += 0.3 * dt;
        STATE.rotationTarget.x += (0 - STATE.rotationTarget.x) * 2.0 * dt;
      } else {
        STATE.rotationTarget.y += 0.1 * dt;
        STATE.rotationTarget.x += (0 - STATE.rotationTarget.x) * 1.2 * dt;
      }

      // smooth rotation
      STATE.rotation.y += (STATE.rotationTarget.y - STATE.rotation.y) * 3.0 * dt;
      STATE.rotation.x += (STATE.rotationTarget.x - STATE.rotation.x) * 3.0 * dt;

      mainGroup.rotation.y = STATE.rotation.y;
      mainGroup.rotation.x = STATE.rotation.x;

      particleSystem.forEach((p) => p.update(dt, STATE.mode, STATE.focusTarget));
      updateSnow(dt);

      composer.render();
    }

    function init() {
      initThree();
      createParticles();
      createDust();
      createSnow();
      setupEvents();
      setMode("TREE");
      updateMusicButtons();

      const loader = $("#loader");
      loader.style.opacity = 0;
      setTimeout(() => loader.remove(), 800);

      animate();
    }

    init();
  </script>
</body>
</html>
