<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NOEL_V3_FULL</title>

  <style>
    body { margin: 0; overflow: hidden; background:#000; font-family: 'Times New Roman', serif; }
    #canvas-container { width: 100vw; height: 100vh; position: absolute; inset: 0; z-index: 1; }

    #ui-layer{
      position:absolute; inset:0; z-index:10; pointer-events:none;
      display:flex; flex-direction:column; align-items:center;
      padding-top:34px; box-sizing:border-box;
    }
    .ui-hidden{ opacity:0; pointer-events:none !important; }

    #loader{
      position:absolute; inset:0; background:#000; z-index:100;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      transition:opacity .8s ease-out;
    }
    .loader-text{
      color:#d4af37; font-size:14px; letter-spacing:4px; margin-top:20px;
      text-transform:uppercase; font-weight:100;
    }
	.ui-hidden{
  	display: none !important;
    }

    .spinner{
      width:40px; height:40px; border:1px solid rgba(212,175,55,.2);
      border-top:1px solid #d4af37; border-radius:50%;
      animation:spin 1s linear infinite;
    }
    @keyframes spin { 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} }

    h1{
      margin:0;
      font-size:54px; font-weight:400; letter-spacing:6px;
      text-shadow:0 0 50px rgba(252,238,167,.6);
      background:linear-gradient(to bottom,#fff,#eebb66);
      -webkit-background-clip:text; -webkit-text-fill-color:transparent;
      font-family:'Cinzel','Times New Roman',serif;
      opacity:.92;
      pointer-events:none;
      text-align:center;
      padding: 0 14px;
    }
    #subtitle{
      margin-top:10px;
      color:rgba(255,255,255,.7);
      font-size:12px;
      letter-spacing:1px;
      text-transform:uppercase;
      pointer-events:none;
      text-align:center;
      padding: 0 14px;
    }

    .controls{
      margin-top:18px;
      pointer-events:auto;
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center; justify-content:center;
      transition:opacity .5s ease;
      padding: 0 14px;
    }
    .btn{
      background:rgba(20,20,20,.6);
      border:1px solid rgba(212,175,55,.35);
      color:#d4af37;
      padding:10px 14px;
      cursor:pointer;
      text-transform:uppercase;
      letter-spacing:2px;
      font-size:10px;
      transition:all .25s;
      display:inline-flex;
      align-items:center;
      gap:8px;
      backdrop-filter:blur(6px);
      border-radius:999px;
      user-select:none;
    }
    .btn:hover{
      background:#d4af37;
      color:#000;
      box-shadow:0 0 18px rgba(212,175,55,.4);
    }
    .btn.secondary{
      border-color: rgba(255,255,255,.12);
      color: rgba(255,255,255,.8);
    }
    .btn.secondary:hover{
      background: rgba(255,255,255,.9);
      color:#000;
      box-shadow:0 0 18px rgba(255,255,255,.25);
    }
    .btn input{ display:none; }

    #hint{
      margin-top:10px;
      color:rgba(212,175,55,.55);
      font-size:9px;
      letter-spacing:1px;
      text-transform:uppercase;
      pointer-events:none;
      text-align:center;
      padding: 0 14px;
    }

    #status-pill{
      margin-top:12px;
      color:rgba(255,255,255,.65);
      font-size:11px;
      letter-spacing:1px;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.08);
      padding:7px 11px;
      border-radius:999px;
      pointer-events:none;
      backdrop-filter:blur(6px);
      text-align:center;
      max-width: min(560px, 92vw);
      line-height: 1.35;
    }

    /* Webcam wrapper (·∫©n) */
    #webcam-wrapper{
      position:absolute; bottom:40px; right:40px;
      width:120px; height:90px;
      border:1px solid rgba(255,255,255,.1);
      overflow:hidden; opacity:0; pointer-events:none;
    }

    /* mobile spacing */
    @media (max-width: 520px){
      h1{ font-size: 40px; letter-spacing: 4px; }
      #subtitle{ font-size: 11px; }
      .btn{ padding: 9px 12px; font-size: 9px; letter-spacing: 1.5px; }
    }
  </style>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
      }
    }
  </script>
</head>

<body>
  <div id="loader">
    <div class="spinner"></div>
    <div class="loader-text">Loading Holiday Magic</div>
  </div>

  <div id="canvas-container"></div>

  <div id="ui-layer">
    <h1 id="title">NOEL</h1>
    <div id="subtitle">Click ·∫£nh ƒë·ªÉ ph√≥ng to ‚Ä¢ K√©o ƒë·ªÉ xoay (mobile)</div>

    <div class="controls" id="controls">
      <label class="btn">
        üñºÔ∏è Th√™m ·∫£nh
        <input type="file" id="file-input" multiple accept="image/*">
      </label>

      <button class="btn" id="btn-music">üé∂ Nh·∫°c: T·∫Øt</button>

      <label class="btn secondary">
        ‚¨ÜÔ∏è Upload nh·∫°c
        <input type="file" id="audio-input" accept="audio/*">
      </label>

      <button class="btn secondary" id="btn-snow">‚ùÑÔ∏è Tuy·∫øt: B·∫≠t</button>

      <button class="btn secondary" id="btn-mode">üîÅ Mode: TREE</button>
    </div>

    <div id="hint">Ph√≠m t·∫Øt: 1=Tree ‚Ä¢ 2=Scatter ‚Ä¢ 3=Focus ‚Ä¢ ESC=Tho√°t Focus ‚Ä¢ Space=Nh·∫°c ‚Ä¢ S=Tuy·∫øt ‚Ä¢ H=·∫®n n√∫t</div>
    <div id="status-pill">Gesture: ƒëang kh·ªüi t·∫°o‚Ä¶ (n·∫øu webcam b·ªã b·∫≠n, hi·ªáu ·ª©ng v·∫´n ch·∫°y b√¨nh th∆∞·ªùng)</div>
  </div>

  <div id="webcam-wrapper">
    <video id="webcam" autoplay playsinline style="display:none;"></video>
    <canvas id="webcam-preview"></canvas>
  </div>

  <!-- Audio element (ngu·ªìn s·∫Ω set b·∫±ng upload ho·∫∑c URL) -->
  <audio id="bgm" crossorigin="anonymous"></audio>

  <script type="module">
    console.log("RUNNING NOEL_V3_FULL", new Date().toISOString());

    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --------- Helpers (UI) ----------
    const $ = (sel) => document.querySelector(sel);
    const titleEl = $("#title");
    const subtitleEl = $("#subtitle");
    const statusEl = $("#status-pill");
    const controlsEl = $("#controls");
    function setStatus(t){ statusEl.textContent = t; }
    function setTitle(t){ titleEl.textContent = t; }

    const GREETINGS = [
      "Merry Christmas ‚ú®",
      "Gi√°ng Sinh An L√†nh üéÑ",
      "An Nhi√™n & ·∫§m √Åp ü§ç",
      "Ch√∫c B·∫°n Vui V·∫ª üéÅ",
      "H·∫°nh Ph√∫c Ng·∫≠p Tr√†n ‚ú®",
      "Peace ‚Ä¢ Love ‚Ä¢ Joy üïØÔ∏è",
      "Noel Vui V·∫ª ü•Ç",
      "Th·∫≠t Nhi·ªÅu May M·∫Øn ‚≠ê"
    ];
    function randomGreeting(){
      return GREETINGS[Math.floor(Math.random()*GREETINGS.length)];
    }

    // --------- Device tuning ----------
    const isMobile = matchMedia("(max-width: 768px)").matches || /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    const DPR = Math.min(window.devicePixelRatio || 1, isMobile ? 1.6 : 2.0);

    // --------- CONFIG ----------
    const CONFIG = {
      colors: {
        bg: 0x000000,
        champagneGold: 0xffd966,
        deepGreen: 0x03180a,
        accentRed: 0x990000,
      },
      particles: {
        count: isMobile ? 900 : 1500,
        dustCount: isMobile ? 1400 : 2500,
        treeHeight: 24,
        treeRadius: 8
      },
      snow: {
        enabled: true,
        count: isMobile ? 900 : 1800,
        area: 60,            // spread area
        fallSpeed: 8.5,
        drift: 1.2
      },
      camera: { z: 50 }
    };

    const STATE = {
      mode: 'TREE',          // TREE | SCATTER | FOCUS
      focusTarget: null,
      hand: { detected: false, x: 0, y: 0 },
      rotation: { x: 0, y: 0 },          // current rotation
      rotationTarget: { x: 0, y: 0 },    // for smoothing
      modeTarget: 'TREE',                // desired mode
      gestureEnabled: false,

      // audio reactive
      musicOn: false,
      audioReady: false,
      beat: 0,       // 0..1 (smoothed)
      snowOn: true,

      // pointer interaction
      isPointerDown: false,
      lastX: 0,
      lastY: 0
    };

    let scene, camera, renderer, composer;
    let mainGroup;
    let clock = new THREE.Clock();
    let particleSystem = [];
    let photoMeshGroup = new THREE.Group();

    // lights refs for audio-reactive
    let ambient, innerLight, spotGold, spotBlue, fill;
    let bloomPass;

    // raycaster for click photos
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    // MediaPipe
    let handLandmarker = null;
    let video = null;
    let lastVideoTime = -1;

    // textures
    let caneTexture = null;

    // snow
    let snowPoints = null;
    let snowGeo = null;
    let snowVel = null;

    // Audio analyzer
    const audioEl = $("#bgm");
    let audioCtx = null, analyser = null, sourceNode = null, freqData = null;

    // ---------- INIT ----------
    async function init() {
      initThree();
      setupEnvironment();
      setupLights();
      createTextures();
      createParticles();
      createDust();
      createSnow();
      setupPostProcessing();
      setupEvents();

      await initMediaPipeSafe(); // safe

      const loader = $("#loader");
      loader.style.opacity = 0;
      setTimeout(() => loader.remove(), 800);

      setStatus("S·∫µn s√†ng ‚úÖ ‚Ä¢ Click ·∫£nh ƒë·ªÉ focus ‚Ä¢ Space b·∫≠t nh·∫°c ‚Ä¢ S b·∫≠t/t·∫Øt tuy·∫øt");
      animate();
    }

    function initThree() {
      const container = $("#canvas-container");

      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.colors.bg);
      scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.01);

      camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, CONFIG.camera.z);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(DPR);
      renderer.toneMapping = THREE.ReinhardToneMapping;
      renderer.toneMappingExposure = 2.2;

      container.appendChild(renderer.domElement);

      mainGroup = new THREE.Group();
      scene.add(mainGroup);
      mainGroup.add(photoMeshGroup);
    }

    function setupEnvironment() {
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
    }

    function setupLights() {
      ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);

      innerLight = new THREE.PointLight(0xffaa00, 2, 20);
      innerLight.position.set(0, 5, 0);
      mainGroup.add(innerLight);

      spotGold = new THREE.SpotLight(0xffcc66, 1200);
      spotGold.position.set(30, 40, 40);
      spotGold.angle = 0.5;
      spotGold.penumbra = 0.5;
      scene.add(spotGold);

      spotBlue = new THREE.SpotLight(0x6688ff, 600);
      spotBlue.position.set(-30, 20, -30);
      scene.add(spotBlue);

      fill = new THREE.DirectionalLight(0xffeebb, 0.8);
      fill.position.set(0, 0, 50);
      scene.add(fill);
    }

    function setupPostProcessing() {
      const renderScene = new RenderPass(scene, camera);
      bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5, 0.4, 0.85
      );
      bloomPass.threshold = 0.7;
      bloomPass.strength = 0.45;
      bloomPass.radius = 0.4;

      composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);
    }

    function createTextures() {
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, 128, 128);

      ctx.fillStyle = '#880000';
      ctx.beginPath();
      for (let i = -128; i < 256; i += 32) {
        ctx.moveTo(i, 0);
        ctx.lineTo(i + 32, 128);
        ctx.lineTo(i + 16, 128);
        ctx.lineTo(i - 16, 0);
      }
      ctx.fill();

      caneTexture = new THREE.CanvasTexture(canvas);
      caneTexture.wrapS = THREE.RepeatWrapping;
      caneTexture.wrapT = THREE.RepeatWrapping;
      caneTexture.repeat.set(3, 3);
    }

    class Particle {
      constructor(mesh, type, isDust = false) {
        this.mesh = mesh;
        this.type = type;
        this.isDust = isDust;

        this.posTree = new THREE.Vector3();
        this.posScatter = new THREE.Vector3();
        this.baseScale = mesh.scale.x;

        const speedMult = (type === 'PHOTO') ? 0.25 : 2.0;
        this.spinSpeed = new THREE.Vector3(
          (Math.random() - 0.5) * speedMult,
          (Math.random() - 0.5) * speedMult,
          (Math.random() - 0.5) * speedMult
        );

        this.calculatePositions();
      }

      calculatePositions() {
        const h = CONFIG.particles.treeHeight;
        const halfH = h / 2;

        let t = Math.random();
        t = Math.pow(t, 0.8);
        const y = (t * h) - halfH;

        let rMax = CONFIG.particles.treeRadius * (1.0 - t);
        if (rMax < 0.5) rMax = 0.5;

        const angle = t * 50 * Math.PI + Math.random() * Math.PI;
        const r = rMax * (0.8 + Math.random() * 0.4);
        this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);

        let rScatter = this.isDust ? (12 + Math.random() * 20) : (8 + Math.random() * 12);
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        this.posScatter.set(
          rScatter * Math.sin(phi) * Math.cos(theta),
          rScatter * Math.sin(phi) * Math.sin(theta),
          rScatter * Math.cos(phi)
        );
      }

      update(dt, mode, focusTargetMesh) {
        let target = this.posTree;

        if (mode === 'SCATTER') target = this.posScatter;
        else if (mode === 'FOCUS') {
          if (this.mesh === focusTargetMesh) {
            const desiredWorldPos = new THREE.Vector3(0, 2, 35);
            const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
            target = desiredWorldPos.applyMatrix4(invMatrix);
          } else {
            target = this.posScatter;
          }
        }

        const lerpSpeed = (mode === 'FOCUS' && this.mesh === focusTargetMesh) ? 6.0 : 2.4;
        this.mesh.position.lerp(target, lerpSpeed * dt);

        if (mode === 'SCATTER') {
          this.mesh.rotation.x += this.spinSpeed.x * dt;
          this.mesh.rotation.y += this.spinSpeed.y * dt;
          this.mesh.rotation.z += this.spinSpeed.z * dt;
        } else if (mode === 'TREE') {
          this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt);
          this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt);
          this.mesh.rotation.y += 0.5 * dt;
        }

        if (mode === 'FOCUS' && this.mesh === focusTargetMesh) {
          this.mesh.lookAt(camera.position);
        }

        let s = this.baseScale;

        if (this.isDust) {
          // dust shimmer
          s = this.baseScale * (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id));
          if (mode === 'TREE') s = 0;
        } else if (mode === 'SCATTER' && this.type === 'PHOTO') {
          s = this.baseScale * 2.2;
        } else if (mode === 'FOCUS') {
          if (this.mesh === focusTargetMesh) s = 4.6;
          else s = this.baseScale * 0.85;
        }

        this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 4 * dt);
      }
    }

    // ---------- CREATE ----------
    function createParticles() {
      const sphereGeo = new THREE.SphereGeometry(0.5, 26, 26);
      const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55);

      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.3, 0),
        new THREE.Vector3(0.1, 0.5, 0), new THREE.Vector3(0.3, 0.4, 0)
      ]);
      const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false);

      const goldMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.champagneGold,
        metalness: 1.0, roughness: 0.1,
        envMapIntensity: 2.0,
        emissive: 0x443300,
        emissiveIntensity: 0.3
      });

      const greenMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.deepGreen,
        metalness: 0.2, roughness: 0.8,
        emissive: 0x002200,
        emissiveIntensity: 0.2
      });

      const redMat = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.accentRed,
        metalness: 0.3, roughness: 0.2, clearcoat: 1.0,
        emissive: 0x330000
      });

      const candyMat = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.4 });

      for (let i = 0; i < CONFIG.particles.count; i++) {
        const rand = Math.random();
        let mesh, type;

        if (rand < 0.40) { mesh = new THREE.Mesh(boxGeo, greenMat); type = 'BOX'; }
        else if (rand < 0.70) { mesh = new THREE.Mesh(boxGeo, goldMat); type = 'GOLD_BOX'; }
        else if (rand < 0.92) { mesh = new THREE.Mesh(sphereGeo, goldMat); type = 'GOLD_SPHERE'; }
        else if (rand < 0.97) { mesh = new THREE.Mesh(sphereGeo, redMat); type = 'RED'; }
        else { mesh = new THREE.Mesh(candyGeo, candyMat); type = 'CANE'; }

        const s = 0.4 + Math.random() * 0.5;
        mesh.scale.set(s, s, s);
        mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);

        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, type, false));
      }

      const starGeo = new THREE.OctahedronGeometry(1.2, 0);
      const starMat = new THREE.MeshStandardMaterial({
        color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 1.0,
        metalness: 1.0, roughness: 0
      });
      const star = new THREE.Mesh(starGeo, starMat);
      star.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0);
      mainGroup.add(star);
    }

    function createDust() {
      const geo = new THREE.TetrahedronGeometry(0.08, 0);
      const mat = new THREE.MeshBasicMaterial({ color: 0xffeebb, transparent: true, opacity: 0.78 });

      for (let i = 0; i < CONFIG.particles.dustCount; i++) {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.scale.setScalar(0.5 + Math.random());
        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, 'DUST', true));
      }
    }

    function addPhotoToScene(texture) {
      const frameGeo = new THREE.BoxGeometry(1.4, 1.4, 0.05);
      const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.champagneGold, metalness: 1.0, roughness: 0.1 });
      const frame = new THREE.Mesh(frameGeo, frameMat);

      const photoGeo = new THREE.PlaneGeometry(1.2, 1.2);
      const photoMat = new THREE.MeshBasicMaterial({ map: texture });
      const photo = new THREE.Mesh(photoGeo, photoMat);
      photo.position.z = 0.04;

      const group = new THREE.Group();
      group.userData.isPhotoGroup = true;
      group.add(frame);
      group.add(photo);

      const s = 0.8;
      group.scale.set(s, s, s);

      photoMeshGroup.add(group);
      particleSystem.push(new Particle(group, 'PHOTO', false));
    }

    function handleImageUpload(e) {
      const files = e.target.files;
      if (!files || !files.length) return;

      Array.from(files).forEach(f => {
        const reader = new FileReader();
        reader.onload = (ev) => {
          new THREE.TextureLoader().load(ev.target.result, (t) => {
            t.colorSpace = THREE.SRGBColorSpace;
            addPhotoToScene(t);
            setStatus("ƒê√£ th√™m ·∫£nh ‚úÖ ‚Ä¢ Click ·∫£nh ƒë·ªÉ focus (ESC ƒë·ªÉ tho√°t)");
          });
        };
        reader.readAsDataURL(f);
      });
    }

    // ---------- SNOW ----------
    function createSnow() {
      const count = CONFIG.snow.count;
      const area = CONFIG.snow.area;

      snowGeo = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      snowVel = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        const ix = i * 3;
        positions[ix + 0] = (Math.random() - 0.5) * area;
        positions[ix + 1] = (Math.random() * area * 0.9) - (area * 0.2);
        positions[ix + 2] = (Math.random() - 0.5) * area;

        snowVel[ix + 0] = (Math.random() - 0.5) * CONFIG.snow.drift;
        snowVel[ix + 1] = - (CONFIG.snow.fallSpeed * (0.6 + Math.random() * 0.8));
        snowVel[ix + 2] = (Math.random() - 0.5) * CONFIG.snow.drift;
      }

      snowGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

      const snowMat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: isMobile ? 0.14 : 0.12,
        transparent: true,
        opacity: 0.75,
        depthWrite: false
      });

      snowPoints = new THREE.Points(snowGeo, snowMat);
      scene.add(snowPoints);
      STATE.snowOn = true;
    }

    function updateSnow(dt) {
      if (!snowPoints || !STATE.snowOn) return;

      const area = CONFIG.snow.area;
      const pos = snowGeo.attributes.position.array;

      for (let i = 0; i < CONFIG.snow.count; i++) {
        const ix = i * 3;

        pos[ix + 0] += snowVel[ix + 0] * dt;
        pos[ix + 1] += snowVel[ix + 1] * dt;
        pos[ix + 2] += snowVel[ix + 2] * dt;

        // wrap
        if (pos[ix + 1] < -area * 0.6) {
          pos[ix + 1] = area * 0.6;
          pos[ix + 0] = (Math.random() - 0.5) * area;
          pos[ix + 2] = (Math.random() - 0.5) * area;
        }
        if (pos[ix + 0] > area * 0.6) pos[ix + 0] = -area * 0.6;
        if (pos[ix + 0] < -area * 0.6) pos[ix + 0] = area * 0.6;
        if (pos[ix + 2] > area * 0.6) pos[ix + 2] = -area * 0.6;
        if (pos[ix + 2] < -area * 0.6) pos[ix + 2] = area * 0.6;
      }

      snowGeo.attributes.position.needsUpdate = true;
    }

    // ---------- AUDIO ----------
    async function ensureAudioGraph() {
      if (STATE.audioReady) return true;

      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 1024;
        analyser.smoothingTimeConstant = 0.85;

        sourceNode = audioCtx.createMediaElementSource(audioEl);
        sourceNode.connect(analyser);
        analyser.connect(audioCtx.destination);

        freqData = new Uint8Array(analyser.frequencyBinCount);
        STATE.audioReady = true;
        return true;
      } catch (e) {
        console.warn("Audio init fail:", e);
        setStatus("Kh√¥ng b·∫≠t ƒë∆∞·ª£c audio analyzer (tr√¨nh duy·ªát ch·∫∑n). B·∫°n v·∫´n d√πng ƒë∆∞·ª£c hi·ªáu ·ª©ng b√¨nh th∆∞·ªùng.");
        return false;
      }
    }

    function getBeatLevel() {
      if (!STATE.audioReady || !analyser || !freqData || audioEl.paused) return 0;

      analyser.getByteFrequencyData(freqData);

      // l·∫•y nƒÉng l∆∞·ª£ng v√πng bass-mid (ƒë∆°n gi·∫£n nh∆∞ng hi·ªáu qu·∫£)
      let sum = 0;
      const from = Math.floor(freqData.length * 0.02);
      const to   = Math.floor(freqData.length * 0.18);
      for (let i = from; i < to; i++) sum += freqData[i];

      const avg = sum / (to - from) / 255; // 0..1
      return avg;
    }

    function applyAudioReactive(dt) {
      const raw = getBeatLevel();
      // smooth beat
      STATE.beat += (raw - STATE.beat) * (6.0 * dt);
      const b = STATE.beat;

      // √°nh s√°ng nh·ªãp theo nh·∫°c
      innerLight.intensity = 1.7 + b * 3.0;
      spotGold.intensity   = 950 + b * 700;
      spotBlue.intensity   = 450 + b * 550;
      ambient.intensity    = 0.55 + b * 0.25;

      // bloom nh·ªãp theo nh·∫°c (nh·∫π th√¥i ƒë·ªÉ kh√¥ng ch√°y)
      bloomPass.strength = 0.38 + b * 0.22;

      // ƒë·ªïi hue nh·∫π cho spotGold theo beat
      const h = (0.10 + b * 0.06) % 1;   // v√†ng -> v√†ng xanh nh·∫π
      const s = 0.65;
      const l = 0.55;
      spotGold.color.setHSL(h, s, l);
    }

    async function toggleMusic() {
      // c·∫ßn user gesture => g·ªçi trong click/keydown
      const ok = await ensureAudioGraph();
      if (!ok) return;

      if (audioCtx.state === "suspended") {
        await audioCtx.resume();
      }

      if (audioEl.src === "" || audioEl.src == null) {
        setStatus("B·∫°n ch∆∞a upload nh·∫°c üé∂ ‚Ä¢ B·∫•m 'Upload nh·∫°c' ƒë·ªÉ ch·ªçn file mp3/m4a...");
        return;
      }

      if (audioEl.paused) {
        try {
          await audioEl.play();
          STATE.musicOn = true;
          $("#btn-music").textContent = "üé∂ Nh·∫°c: B·∫≠t";
          setStatus("Nh·∫°c ƒëang ph√°t üé∂ ‚Ä¢ √Ånh s√°ng s·∫Ω nh·∫•p nh√°y theo nh·∫°c");
        } catch (e) {
          console.warn("Play blocked:", e);
          setStatus("Tr√¨nh duy·ªát ch·∫∑n autoplay. B·∫•m l·∫°i n√∫t Nh·∫°c ƒë·ªÉ b·∫≠t.");
        }
      } else {
        audioEl.pause();
        STATE.musicOn = false;
        $("#btn-music").textContent = "üé∂ Nh·∫°c: T·∫Øt";
        setStatus("Nh·∫°c ƒë√£ t·∫Øt.");
      }
    }

    function handleAudioUpload(e) {
      const file = e.target.files?.[0];
      if (!file) return;

      const url = URL.createObjectURL(file);
      audioEl.src = url;
      audioEl.loop = true;
      audioEl.volume = 0.7;

      setStatus(`ƒê√£ load nh·∫°c: ${file.name} ‚úÖ ‚Ä¢ B·∫•m 'Nh·∫°c: T·∫Øt/B·∫≠t' ho·∫∑c Space ƒë·ªÉ ph√°t`);
    }

    // ---------- MEDIAPIPE (SAFE) ----------
    async function initMediaPipeSafe() {
      // Gesture ch·ªâ l√† ‚Äúbonus‚Äù. Camera l·ªói th√¨ v·∫´n ch·∫°y OK.
      setStatus("Gesture: ƒëang kh·ªüi t·∫°o‚Ä¶ (n·∫øu webcam b·∫≠n s·∫Ω t·ª± t·∫Øt)");

      let vision = null;
      try {
        vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
      } catch (e) {
        console.warn("MediaPipe wasm load fail:", e);
        setStatus("Gesture: t·∫Øt (kh√¥ng load ƒë∆∞·ª£c MediaPipe) ‚Ä¢ B·∫°n v·∫´n d√πng ph√≠m 1/2/3");
        return;
      }

      try {
        try {
          handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
              modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
              delegate: "GPU"
            },
            runningMode: "VIDEO",
            numHands: 1
          });
        } catch (gpuErr) {
          console.warn("GPU delegate l·ªói, chuy·ªÉn CPU:", gpuErr);
          handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
              modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
              delegate: "CPU"
            },
            runningMode: "VIDEO",
            numHands: 1
          });
        }
      } catch (e) {
        console.warn("HandLandmarker init fail:", e);
        setStatus("Gesture: t·∫Øt (kh·ªüi t·∫°o model l·ªói) ‚Ä¢ B·∫°n v·∫´n d√πng ph√≠m 1/2/3");
        return;
      }

      video = $("#webcam");
      if (!navigator.mediaDevices?.getUserMedia) {
        setStatus("Gesture: t·∫Øt (tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ webcam) ‚Ä¢ D√πng ph√≠m 1/2/3");
        return;
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user" },
          audio: false
        });
        video.srcObject = stream;
        await new Promise((resolve) => video.addEventListener("loadeddata", resolve, { once: true }));

        STATE.gestureEnabled = true;
        setStatus("Gesture: b·∫≠t ‚úÖ (pinch=Focus ‚Ä¢ m·ªü tay=Scatter ‚Ä¢ n·∫Øm tay=Tree) ‚Ä¢ Click ·∫£nh c≈©ng focus ƒë∆∞·ª£c");
        predictWebcamLoop();
      } catch (err) {
        console.warn("Webcam kh√¥ng m·ªü ƒë∆∞·ª£c:", err);
        STATE.gestureEnabled = false;
        setStatus("Gesture: t·∫Øt (webcam b·∫≠n/b·ªã ch·∫∑n) ‚Ä¢ D√πng click/ph√≠m 1/2/3");
      }
    }

    function predictWebcamLoop() {
      if (!STATE.gestureEnabled || !handLandmarker || !video) return;

      if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        const result = handLandmarker.detectForVideo(video, performance.now());
        processGestures(result);
      }
      requestAnimationFrame(predictWebcamLoop);
    }

    function processGestures(result) {
      if (result.landmarks && result.landmarks.length > 0) {
        STATE.hand.detected = true;

        const lm = result.landmarks[0];
        STATE.hand.x = (lm[9].x - 0.5) * 2;
        STATE.hand.y = (lm[9].y - 0.5) * 2;

        const thumb = lm[4];
        const index = lm[8];
        const wrist = lm[0];

        const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);

        const tips = [lm[8], lm[12], lm[16], lm[20]];
        let avgDist = 0;
        tips.forEach(t => avgDist += Math.hypot(t.x - wrist.x, t.y - wrist.y));
        avgDist /= 4;

        if (pinchDist < 0.05) {
          setMode('FOCUS', { randomPhoto: true });
        } else if (avgDist < 0.25) {
          setMode('TREE');
        } else if (avgDist > 0.4) {
          setMode('SCATTER');
        }
      } else {
        STATE.hand.detected = false;
      }
    }

    // ---------- MODE / FOCUS ----------
    function setMode(mode, opts = {}) {
      STATE.modeTarget = mode;

      if (mode !== 'FOCUS') {
        STATE.focusTarget = null;
      } else {
        if (opts.targetMesh) {
          STATE.focusTarget = opts.targetMesh;
        } else if (opts.randomPhoto) {
          const photos = particleSystem.filter(p => p.type === 'PHOTO');
          STATE.focusTarget = photos.length ? photos[Math.floor(Math.random()*photos.length)].mesh : null;
        } else if (!STATE.focusTarget) {
          const photos = particleSystem.filter(p => p.type === 'PHOTO');
          STATE.focusTarget = photos.length ? photos[0].mesh : null;
        }

        if (STATE.focusTarget) setTitle(randomGreeting());
      }

      $("#btn-mode").textContent = `üîÅ Mode: ${STATE.modeTarget}`;
    }

    function exitFocus() {
      setTitle("NOEL");
      setMode('SCATTER');
    }

    // ---------- Click / Tap to focus ----------
    function updatePointerFromEvent(ev) {
      const rect = renderer.domElement.getBoundingClientRect();
      const x = (ev.clientX - rect.left) / rect.width;
      const y = (ev.clientY - rect.top) / rect.height;
      pointer.x = x * 2 - 1;
      pointer.y = -(y * 2 - 1);
    }

    function tryPickPhoto(ev) {
      updatePointerFromEvent(ev);
      raycaster.setFromCamera(pointer, camera);

      const hits = raycaster.intersectObjects(photoMeshGroup.children, true);
      if (!hits.length) return false;

      // t√¨m group cha c√≥ userData.isPhotoGroup
      let obj = hits[0].object;
      while (obj && !obj.userData?.isPhotoGroup) obj = obj.parent;
      if (!obj) return false;

      setMode('FOCUS', { targetMesh: obj });
      setStatus("FOCUS ‚úÖ ‚Ä¢ ESC ƒë·ªÉ tho√°t ‚Ä¢ 1/2 chuy·ªÉn mode ‚Ä¢ Click ·∫£nh kh√°c ƒë·ªÉ ƒë·ªïi");
      return true;
    }

    // ---------- Events ----------
    function setupEvents() {
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      $("#file-input").addEventListener('change', handleImageUpload);
      $("#audio-input").addEventListener('change', handleAudioUpload);

      $("#btn-music").addEventListener('click', toggleMusic);
      $("#btn-snow").addEventListener('click', () => {
        STATE.snowOn = !STATE.snowOn;
        $("#btn-snow").textContent = `‚ùÑÔ∏è Tuy·∫øt: ${STATE.snowOn ? "B·∫≠t" : "T·∫Øt"}`;
      });
      $("#btn-mode").addEventListener('click', () => {
        // cycle
        const next = (STATE.modeTarget === 'TREE') ? 'SCATTER' : (STATE.modeTarget === 'SCATTER' ? 'FOCUS' : 'TREE');
        setMode(next, { randomPhoto: true });
      });

      // click canvas focus
      renderer.domElement.addEventListener('click', (ev) => {
        // n·∫øu ƒëang drag th√¨ b·ªè
        if (STATE.isPointerDown) return;
        tryPickPhoto(ev);
      });

      // pointer drag rotate (desktop + mobile)
      renderer.domElement.addEventListener('pointerdown', (ev) => {
        STATE.isPointerDown = true;
        STATE.lastX = ev.clientX;
        STATE.lastY = ev.clientY;
      });
      window.addEventListener('pointerup', () => {
        STATE.isPointerDown = false;
      });
      window.addEventListener('pointermove', (ev) => {
        if (!STATE.isPointerDown) return;
        const dx = ev.clientX - STATE.lastX;
        const dy = ev.clientY - STATE.lastY;
        STATE.lastX = ev.clientX;
        STATE.lastY = ev.clientY;

        // adjust target rotation
        STATE.rotationTarget.y += dx * 0.006;
        STATE.rotationTarget.x += dy * 0.0025;
        STATE.rotationTarget.x = THREE.MathUtils.clamp(STATE.rotationTarget.x, -0.65, 0.65);
      });

      // keyboard
      window.addEventListener('keydown', async (e) => {
        const k = e.key.toLowerCase();

        if (k === 'h') {
  // ·∫®n/hi·ªán ƒë√∫ng 3 d√≤ng: subtitle + controls + hint
  	subtitleEl.classList.toggle('ui-hidden');
  	controlsEl.classList.toggle('ui-hidden');
  	document.getElementById('hint')?.classList.toggle('ui-hidden');
	}

        if (k === '1') setMode('TREE');
        if (k === '2') setMode('SCATTER');
        if (k === '3') setMode('FOCUS', { randomPhoto: true });
        if (k === 'escape') exitFocus();
        if (k === 's') {
          STATE.snowOn = !STATE.snowOn;
          $("#btn-snow").textContent = `‚ùÑÔ∏è Tuy·∫øt: ${STATE.snowOn ? "B·∫≠t" : "T·∫Øt"}`;
        }
        if (k === ' '){
          e.preventDefault();
          await toggleMusic();
        }
      });

      // pause rendering work when tab hidden (mobile friendly)
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          if (!audioEl.paused) audioEl.pause();
          STATE.musicOn = false;
          $("#btn-music").textContent = "üé∂ Nh·∫°c: T·∫Øt";
        }
      }, { passive: true });
    }

    // ---------- Animate ----------
    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);

      // Smooth mode switching
      if (STATE.mode !== STATE.modeTarget) {
        // when switching to focus without target, pick random
        if (STATE.modeTarget === 'FOCUS' && !STATE.focusTarget) {
          const photos = particleSystem.filter(p => p.type === 'PHOTO');
          STATE.focusTarget = photos.length ? photos[Math.floor(Math.random()*photos.length)].mesh : null;
        }
        // apply immediately (movement is already eased inside Particle.update)
        STATE.mode = STATE.modeTarget;
      }

      // Rotation target logic
      // If gesture active in SCATTER, let hand steer rotationTarget
      if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
        const targetRotY = STATE.hand.x * Math.PI * 0.9;
        const targetRotX = STATE.hand.y * Math.PI * 0.25;
        STATE.rotationTarget.y += (targetRotY - STATE.rotationTarget.y) * 4.0 * dt;
        STATE.rotationTarget.x += (targetRotX - STATE.rotationTarget.x) * 4.0 * dt;
      } else {
        // idle drift
        if (STATE.mode === 'TREE') {
          STATE.rotationTarget.y += 0.3 * dt;
          STATE.rotationTarget.x += (0 - STATE.rotationTarget.x) * 2.0 * dt;
        } else {
          STATE.rotationTarget.y += 0.1 * dt;
          STATE.rotationTarget.x += (0 - STATE.rotationTarget.x) * 1.2 * dt;
        }
      }

      // smooth follow
      STATE.rotation.y += (STATE.rotationTarget.y - STATE.rotation.y) * 3.0 * dt;
      STATE.rotation.x += (STATE.rotationTarget.x - STATE.rotation.x) * 3.0 * dt;

      mainGroup.rotation.y = STATE.rotation.y;
      mainGroup.rotation.x = STATE.rotation.x;

      // update particles
      particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));

      // snow
      updateSnow(dt);

      // audio reactive
      applyAudioReactive(dt);

      composer.render();
    }

    init();
  </script>
</body>
</html>
